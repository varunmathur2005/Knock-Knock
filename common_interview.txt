References:
https://youtu.be/ffJ38dBzrlY?feature=shared


1). Why shadcn ui?

--> Not a component library
--> Keeps component in component folder
--> When we use materials ui or chakra we have no access to the actual components code
--> The way those components are working
--> Gives flexibility to modify components (complete ownership)

2). How routes work in nextjs?
= Time stamp 18.39

3). Route groups?
19:33 --> Used for structuring files
eg: (dashboard) dont matter for the url


NOTE: After sign up we want to take user to a page where we say, your request will be processed. So we will change NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/dashboard
to /after-sign-up 

4). What is useState?

useState is a React Hook that allows you to add state to functional components. State is essentially a way to store information that can change over time and cause the component to re-render when the state changes
When you call useState, it returns an array with two elements:
The current state value.
A function to update that state value.
isMounted is the state variable, initialized to false.
setIsMounted is the function used to update the isMounted state.

5). What is useEffect?

useEffect is another React Hook that allows you to perform side effects in your functional components. Side effects can include things like data fetching, setting up subscriptions, and manually changing the DOM.
How does useEffect work?

The useEffect hook runs after the component renders. It can be configured to run only once (on mount), on every render, or when specific dependencies change.
The effect can return a cleanup function, which React will call when the component unmounts or before the effect runs again.
This effect runs after the component is mounted ([] as the dependency array means it only runs once).
It updates isMounted to true once the component has been rendered for the first time.

6).What is isMounted?

isMounted is a state variable that you defined using useState.
In this context, it is used to track whether the component has been mounted (i.e., fully rendered for the first time).
Why is isMounted used?

The isMounted check ensures that certain parts of your component are only rendered or executed after the component has been mounted. This can be particularly useful when rendering components or performing actions that depend on the DOM.

7).What is setIsMounted?

setIsMounted is the function you get from calling useState. It's used to update the value of isMounted.
How is setIsMounted used?

In the useEffect hook, setIsMounted(true) is called to update the isMounted state to true after the component has been mounted.

-->The pattern of using useState, useEffect, and isMounted is often used in Next.js applications where you want to ensure that certain code only runs in the browser, not during server-side rendering (SSR). This is important because some components or operations might only be valid or necessary when running in the browser.
Your Component:

The MobileSidebar component uses this pattern to ensure that the sidebar and the Sheet component are only rendered on the client side after the component has been mounted.
This avoids any potential issues with SSR, such as trying to access the window object or manipulating the DOM before it exists.


8).A hydration error in React (and by extension in Next.js, which uses React) occurs during the process where React tries to "hydrate" the server-rendered HTML on the client side. Hydration is the process where React takes the static HTML that was pre-rendered on the server and "reconnects" it to the React components on the client side.

When Does Hydration Happen?
Server-Side Rendering (SSR): Next.js generates static HTML for your pages on the server. This HTML is then sent to the browser.
Client-Side Hydration: When the HTML arrives at the client (the user's browser), React "hydrates" it by attaching the React components and adding interactivity (like event handlers).
What Causes Hydration Errors?
Hydration errors typically occur when there's a mismatch between the HTML generated on the server and the HTML that React expects to see on the client. Some common causes include:

Dynamic Content:

If the content rendered on the client side differs from the content rendered on the server side, React will throw a hydration error. This can happen if you rely on browser-specific APIs (like window or document) or random values that differ between server and client renders.
Conditional Rendering:

If you conditionally render components or elements based on state or props that might differ between the server and client, this can cause mismatches. For example, if you use useEffect to update a piece of the DOM that affects layout, this could cause issues.
Incorrect Usage of useEffect:

Since useEffect only runs on the client side, any DOM manipulations done inside useEffect that affect the structure of the HTML can lead to hydration mismatches.
CSS or Styling Differences:

If CSS is applied differently between server and client, it could cause layout shifts that lead to mismatches in the rendered HTML.
example example
Imagine you have a component that displays the current time:

javascript
Copy code
const CurrentTime = () => {
  const [time, setTime] = useState(new Date().toLocaleTimeString());

  useEffect(() => {
    const timer = setInterval(() => {
      setTime(new Date().toLocaleTimeString());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return <div>{time}</div>;
};
Server-Side Rendering (SSR): When this component is rendered on the server, it captures the server's current time.
Client-Side Hydration: When React hydrates this component on the client, the time will immediately differ because the client will have its own time, potentially causing a mismatch.

How to Prevent Hydration Errors
Use Conditional Rendering Carefully:

Ensure that what is rendered on the server is consistent with what will be rendered on the client.
Avoid Using Browser-Specific APIs in Initial Renders:

Any code that relies on window, document, or other browser-specific APIs should only run on the client (e.g., inside useEffect or useLayoutEffect).
Handle Dynamic Data Carefully:

If your component relies on dynamic data (like the current time), consider deferring the rendering until the client side or ensuring that the server and client will always produce the same initial render.
Check for Warnings:

React will usually warn you in the console if there's a hydration mismatch, so keep an eye on the developer tools console for warnings during development.

Hydration errors are about ensuring that the HTML generated on the server matches what React expects to find on the client. They usually happen due to differences in how content is rendered on the server versus how it's rendered on the client. Understanding the root causes of these errors and applying best practices can help prevent them and ensure a smooth SSR experience.